#include <rocket/uart.h>
#include <rocket/strutils.h>
#include <inttypes.h>
#include <math.h>

// when not using my startup code, the first function to appear is executed.
// We can either have main() be the first one and use forward declarations or
// use a wrapper, as such:
int main_();
int main() { return main_(); }

/* ideally this would be an example of how to use the toolflow
              _____> riscv-lut-startup --\
             /                            \
  clang -> llvm ------------------------------> gas -> riscv-uart-flash
     \___> riscv-lut-compiler -----------/
  
  to write a program in C code and have it built and then run on the FPGA.
  
  Currently the following parts are non-operational:
    - clang does not translate approx-decorated functions and invocations.
      The source code is there, but somehow the compiled clang does not use it.
    - invocation of llvm (through clang) generates multiple .s files
      - this is a problem if LUTs occur in multiple source files:
        the lut translate pass gets called individually, leading to collisions.
    - llc does not appear to be executing the lut translation pass
      - it was included in one way but that broke other parts of clang
      - see the PACO-lut-translate_integration branch of riscv-llvm for a new
        attempt at integrating it.
    - startup code is not generated by llvm. This is a simple matter of invoking
      the riscv-lut-startup tool from LLVM. Has not been done because it is 
      difficult to test and not needed until the aforementioned points are
      covered.
    - lut compilation fails for "large" values for the selectorBits variable.
      This is due to an exceeding of the pla interconnects.
      - more testing is needed with the architecture parameters to find a
        configuration that works better.

  However, LUTs can be used in this way:
    - the LUT input files that would be generated by clang are simply created
      manually
      - list all of them in the LUTS variable in the Makefile.
    - invocation of a LUT is done through the LUTE and LUTE3 macros within C
      code.

  
  */

#define LUTE(idx,arg) ({ \
  uint64_t op1=arg, rv1; \
  asm("lute %0, %1, "#idx ",1\n" : "=r"(rv1) : "r"(op1)); \
  rv1;})

#define LUTE3(idx,arg1,arg2,arg3) ({ \
  uint64_t op1=arg1, op2=arg2, op3=arg3, rv1; \
  asm( \
    "lute3 %0, %1, %2, %3, "#idx "\n" \
    : "=r"(rv1)  \
    : "r"(op1), "r"(op2), "r"(op3)); \
  rv1;})

/* the following is test code for automatic lut generation. I could not make it
  work. */
#define GAMMA_CODE \
  double v; \
  int r; \
  v=(double)a/(double)(1uL<<24); \
  v= 1.0 * v+0.25 /* pow(v,0.25) */ ; \
  if (v>1) v=1; else if (v<0) v=0; \
  r=(int)(v*(double)(1uL<<24)); \
  return r;

#define AX approx( segments="log-left" approximation="linear" )

AX int gamma_1_4_ax(int a) {
  GAMMA_CODE
}

int gamma_1_4(int a) {
  GAMMA_CODE
}

/* test code ends here. */



/** \brief Test application.
  *
  */
int main_() {
  char buf[128];
  uint64_t v;
  int r;
  while(1) {
    v=LUTE(1,14);
    r=0;
    r+=wrstring(buf+r,"value 1 14: ");
    r+=wruint64(buf+r,v);
    uart_println(buf);

    v=LUTE3(0,12,13,14);
    r=0;
    r+=wrstring(buf+r,"value 0 12 13 14: ");
    r+=wruint64(buf+r,v);
    uart_println(buf);

    uart_readln(buf,sizeof(buf));
    uart_println(buf);
  }
  return 0;
}



